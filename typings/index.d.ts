// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@discordjs/collection
//   ../node:events
//   ../ws
//   ../undici
//   ../node:stream

declare module 'erela.js' {
    export * from "erela.js/structures/Manager";
    export * from "erela.js/structures/Node";
    export * from "erela.js/structures/Player";
    export * from "erela.js/structures/Queue";
    export * from "erela.js/structures/Utils";
}

declare module 'erela.js/structures/Manager' {
    import { Collection } from "@discordjs/collection";
    import { EventEmitter } from "node:events";
    import { VoiceState } from "erela.js///erela.js";
    import { Node, NodeOptions } from "erela.js/structures/Node";
    import { Player, PlayerOptions, Track, UnresolvedTrack } from "erela.js/structures/Player";
    import { PluginDataInfo, v4LoadType } from "erela.js/structures/Utils";
    import { LoadType, Plugin, TrackData, TrackEndEvent, TrackExceptionEvent, TrackStartEvent, TrackStuckEvent, VoicePacket, VoiceServer, WebSocketClosedEvent } from "erela.js/structures/Utils";
    export const v4LoadTypes: {
            TrackLoaded: string;
            PlaylistLoaded: string;
            SearchResult: string;
            NoMatches: string;
            LoadFailed: string;
    };
    export const LoadTypes: Record<"TrackLoaded" | "PlaylistLoaded" | "SearchResult" | "NoMatches" | "LoadFailed", LoadType>;
    export interface Manager {
            /**
                * Emitted when a Node is created.
                * @event Manager#nodeCreate
                */
            on(event: "nodeCreate", listener: (node: Node) => void): this;
            /**
                * Emitted when a Node is destroyed.
                * @event Manager#nodeDestroy
                */
            on(event: "nodeDestroy", listener: (node: Node) => void): this;
            /**
                * Emitted when a Node connects.
                * @event Manager#nodeConnect
                */
            on(event: "nodeConnect", listener: (node: Node) => void): this;
            /**
                * Emitted when a Node reconnects.
                * @event Manager#nodeReconnect
                */
            on(event: "nodeReconnect", listener: (node: Node) => void): this;
            /**
                * Emitted when a Node disconnects.
                * @event Manager#nodeDisconnect
                */
            on(event: "nodeDisconnect", listener: (node: Node, reason: {
                    code?: number;
                    reason?: string;
            }) => void): this;
            /**
                * Emitted when a Node has an error.
                * @event Manager#nodeError
                */
            on(event: "nodeError", listener: (node: Node, error: Error) => void): this;
            /**
                * Emitted whenever any Lavalink event is received.
                * @event Manager#nodeRaw
                */
            on(event: "nodeRaw", listener: (payload: unknown) => void): this;
            /**
                * Emitted when a player is created.
                * @event Manager#playerCreate
                */
            on(event: "playerCreate", listener: (player: Player) => void): this;
            /**
                * Emitted when a player is destroyed.
                * @event Manager#playerDestroy
                */
            on(event: "playerDestroy", listener: (player: Player) => void): this;
            /**
                * Emitted when a player queue ends.
                * @event Manager#queueEnd
                */
            on(event: "queueEnd", listener: (player: Player, track: Track | UnresolvedTrack, payload: TrackEndEvent) => void): this;
            /**
                * Emitted when a player is moved to a new voice channel.
                * @event Manager#playerMove
                */
            on(event: "playerMove", listener: (player: Player, initChannel: string, newChannel: string) => void): this;
            /**
                * Emitted when a player is disconnected from it's current voice channel.
                * @event Manager#playerDisconnect
                */
            on(event: "playerDisconnect", listener: (player: Player, oldChannel: string) => void): this;
            /**
                * Emitted when a track starts.
                * @event Manager#trackStart
                */
            on(event: "trackStart", listener: (player: Player, track: Track, payload: TrackStartEvent) => void): this;
            /**
                * Emitted when a track ends.
                * @event Manager#trackEnd
                */
            on(event: "trackEnd", listener: (player: Player, track: Track, payload: TrackEndEvent) => void): this;
            /**
                * Emitted when a track gets stuck during playback.
                * @event Manager#trackStuck
                */
            on(event: "trackStuck", listener: (player: Player, track: Track, payload: TrackStuckEvent) => void): this;
            /**
                * Emitted when a track has an error during playback.
                * @event Manager#trackError
                */
            on(event: "trackError", listener: (player: Player, track: Track | UnresolvedTrack, payload: TrackExceptionEvent) => void): this;
            /**
                * Emitted when a voice connection is closed.
                * @event Manager#socketClosed
                */
            on(event: "socketClosed", listener: (player: Player, payload: WebSocketClosedEvent) => void): this;
    }
    /**
        * The main hub for interacting with Lavalink and using Erela.JS,
        * @noInheritDoc
        */
    export class Manager extends EventEmitter {
            static readonly DEFAULT_SOURCES: Record<SearchPlatform, LavalinkSearchPlatform>;
            static readonly regex: Record<SourcesRegex, RegExp>;
            /** The map of players. */
            readonly players: Collection<string, Player>;
            /** The map of nodes. */
            readonly nodes: Collection<string, Node>;
            /** The options that were set. */
            readonly options: ManagerOptions;
            /** If the Manager got initiated */
            initiated: boolean;
            /** Returns the least used Nodes. */
            get leastUsedNodes(): Collection<string, Node>;
            /** Returns the least used Nodes sorted by amount of calls. */
            get leastUsedNodesCalls(): Collection<string, Node>;
            /** Returns the least used Nodes sorted by amount of players. */
            get leastUsedNodesPlayers(): Collection<string, Node>;
            /** Returns the least used Nodes sorted by amount of memory usage. */
            get leastUsedNodesMemory(): Collection<string, Node>;
            /** Returns the least system load Nodes. */
            get leastLoadNodes(): Collection<string, Node>;
            get leastLoadNodesMemory(): Collection<string, Node>;
            /** Returns the least system load Nodes. */
            get leastLoadNodesCpu(): Collection<string, Node>;
            /**
                * Initiates the Manager class.
                * @param options
                */
            constructor(options: ManagerOptions);
            /**
                * Initiates the Manager.
                * @param {string} clientID
                * @param {{ clientId?: string, clientName?: string, shards?: number }} objectClientData
                */
            init(clientID?: string, objectClientData?: {
                    clientId?: string;
                    clientName?: string;
                    shards?: number;
            }): this;
            searchLocal(query: string, requester?: unknown, customNode?: Node): Promise<SearchResult>;
            /**
                * Searches the enabled sources based off the URL or the `source` property.
                * @param query
                * @param requester
                * @param customNode
                * @returns The search result.
                */
            search(query: string | SearchQuery, requester?: unknown, customNode?: Node): Promise<SearchResult>;
            /**
                    * Searches the a link directly without any source
                    * @param query
                    * @param requester
                    * @param customNode
                    * @returns The search result.
                    */
            searchLink(query: string | SearchQuery, requester?: unknown, customNode?: Node): Promise<SearchResult>;
            validatedQuery(queryString: string, node: Node): void;
            /**
                * Decodes the base64 encoded tracks and returns a TrackData array.
                * @param tracks
                */
            decodeTracks(tracks: string[]): Promise<TrackData[]>;
            /**
                * Decodes the base64 encoded track and returns a TrackData.
                * @param track
                */
            decodeTrack(encodedTrack: string): Promise<TrackData>;
            /**
                * Creates a player or returns one if it already exists.
                * @param options
                */
            create(options: PlayerOptions): Player;
            /**
                * Returns a player or undefined if it does not exist.
                * @param guild
                */
            get(guild: string): Player | undefined;
            /**
                * Destroys a player if it exists.
                * @param guild
                */
            destroy(guild: string): void;
            /**
                * Creates a node or returns one if it already exists.
                * @param options
                */
            createNode(options: NodeOptions): Node;
            /**
                * Destroys a node if it exists.
                * @param identifier
                */
            destroyNode(identifier: string): void;
            /**
                * Sends voice data to the Lavalink server.
                * @param data
                */
            updateVoiceState(data: VoicePacket | VoiceServer | VoiceState): Promise<void>;
    }
    export interface Payload {
            /** The OP code */
            op: number;
            d: {
                    guild_id: string;
                    channel_id: string | null;
                    self_mute: boolean;
                    self_deaf: boolean;
            };
    }
    export interface ManagerOptions {
            /** The array of nodes to connect to. */
            nodes?: NodeOptions[];
            /** The client ID to use. */
            clientId?: string;
            /** Value to use for the `Client-Name` header. */
            clientName?: string;
            /** The shard count. */
            shards?: number;
            /** A array of plugins to use. */
            plugins?: Plugin[];
            /** Whether players should automatically play the next song. */
            autoPlay?: boolean;
            /** An array of track properties to keep. `track` will always be present. */
            trackPartial?: string[];
            /** @default "youtube" The default search platform to use, can be "youtube", "youtube music", "soundcloud", "deezer", "spotify", ... */
            defaultSearchPlatform?: SearchPlatform;
            /** used to decrement the volume to a % */
            volumeDecrementer?: number;
            /** used to change the position_update_interval from 250ms to X ms */
            position_update_interval?: number;
            /** Extra Uris which are allowed to be saved as a unresolved from URI (only provide ones which can be handled by LAVALINK) */
            validUnresolvedUris?: string[];
            /** If the plugin should force-load plugins */
            forceLoadPlugin?: boolean;
            /** Array of valid link-Strings; */
            allowedLinks?: string[];
            /** RegExpressions for all Valid Links, default allowed ones are gotten from Manager#regex, aka for: youtube, spotify, soundcloud, deezer, mp3 urls of any kind, ... */
            allowedLinksRegexes?: RegExp[];
            /** If it should only allow setupped Links */
            onlyAllowAllowedLinks?: boolean;
            /** @default "players" the default sort type to retrieve the least used node */
            defaultLeastUsedNodeSortType?: leastUsedNodeSortType;
            /** @default "memory" the default sort type to retrieve the least load node */
            defaultLeastLoadNodeSortType?: leastLoadNodeSortType;
            /** If it should forceSearch a link via Manager#searchLink then set this to true! */
            forceSearchLinkQueries?: boolean;
            /** If it should use the unresolved Data of unresolved Tracks */
            useUnresolvedData?: boolean;
            /** Custom Useragent */
            userAgent?: string;
            /** Rest max request time */
            restTimeout?: number;
            /** Use the new REST Filter#Volume float Value instead of the % Volume (Library re-calculates it, sounds better, but yea)  */
            applyVolumeAsFilter?: boolean;
            /**
                * Function to send data to the websocket.
                * @param id
                * @param payload
                */
            send(id: string, payload: Payload): void;
    }
    export type leastUsedNodeSortType = "memory" | "calls" | "players";
    export type leastLoadNodeSortType = "cpu" | "memory";
    export type LavalinkSearchPlatform = "ytsearch" | "ytmsearch" | "scsearch" | "spsearch" | "sprec" | "amsearch" | "dzsearch" | "dzisrc" | "sprec" | "ymsearch" | "speak" | "tts";
    export type ErelaSearchPlatform = "youtube" | "youtube music" | "soundcloud" | "ytm" | "yt" | "sc" | "am" | "sp" | "sprec" | "spsuggestion" | "ds" | "dz" | "deezer" | "yandex" | "yandexmusic";
    export type SearchPlatform = LavalinkSearchPlatform | ErelaSearchPlatform;
    export type SourcesRegex = "YoutubeRegex" | "YoutubeMusicRegex" | "SoundCloudRegex" | "SoundCloudMobileRegex" | "DeezerTrackRegex" | "DeezerArtistRegex" | "DeezerEpisodeRegex" | "DeezerMixesRegex" | "DeezerPageLinkRegex" | "DeezerPlaylistRegex" | "DeezerAlbumRegex" | "AllDeezerRegex" | "AllDeezerRegexWithoutPageLink" | "SpotifySongRegex" | "SpotifyPlaylistRegex" | "SpotifyArtistRegex" | "SpotifyEpisodeRegex" | "SpotifyShowRegex" | "SpotifyAlbumRegex" | "AllSpotifyRegex" | "mp3Url" | "m3uUrl" | "m3u8Url" | "mp4Url" | "m4aUrl" | "wavUrl" | "tiktok" | "mixcloud" | "musicYandex" | "radiohost" | "bandcamp" | "appleMusic" | "TwitchTv" | "vimeo";
    export interface SearchQuery {
            /** The source to search from. */
            source?: SearchPlatform | string;
            /** The query to search for. */
            query: string;
    }
    export interface SearchResult {
            /** The load type of the result. */
            loadType: v4LoadType | LoadType;
            /** The array of tracks from the result. */
            tracks: Track[];
            /** The playlist info if the load type is PLAYLIST_LOADED. */
            playlist?: PlaylistInfo;
            /** The plugin info if the load type is PLAYLIST_LOADED. */
            pluginInfo?: Partial<PluginDataInfo> | Record<string, string | number>;
            /** The exception when searching if one. */
            exception?: {
                    /** The message for the exception. */
                    message: string;
                    /** The severity of exception. */
                    severity: string;
            };
    }
    export interface PlaylistInfo {
            /** The playlist name. */
            name: string;
            /** The Playlist Author */
            author?: string;
            /** The Playlist Thumbnail */
            thumbnail?: string;
            /** A Uri to the playlist */
            uri?: string;
            /** The playlist selected track. */
            selectedTrack: Track | null;
            /** The duration of the entire playlist. (calcualted) */
            duration: number;
    }
    export interface LavalinkResult {
            tracks?: TrackData[];
            data?: TrackData[] | TrackData | {
                    tracks: TrackData[];
            };
            loadType: LoadType | v4LoadType;
            exception?: {
                    /** The message for the exception. */
                    message: string;
                    /** The severity of exception. */
                    severity: string;
            };
            playlistInfo: {
                    name: string;
                    selectedTrack?: number;
            } | null;
            pluginInfo: Partial<PluginDataInfo> | Record<string, string | number> | null;
    }
}

declare module 'erela.js/structures/Node' {
    import WebSocket from "ws";
    import { Dispatcher, Pool } from "undici";
    import { Manager } from "erela.js/structures/Manager";
    import { Player, Track, UnresolvedTrack } from "erela.js/structures/Player";
    import { InvalidLavalinkRestRequest, LavalinkPlayer, PlayerEvent, PlayerEvents, PlayerUpdateInfo, RoutePlanner, Session, TrackEndEvent, TrackExceptionEvent, TrackStartEvent, TrackStuckEvent, WebSocketClosedEvent } from "erela.js/structures/Utils";
    import internal from "node:stream";
    export type LavalinkVersion = "v2" | "v3" | "v4";
    export class Node {
            options: NodeOptions;
            /** The socket for the node. */
            socket: WebSocket | null;
            /** The HTTP pool used for rest calls. */
            http: Pool;
            /** The amount of rest calls the node has made. */
            calls: number;
            /** The stats for the node. */
            stats: NodeStats;
            manager: Manager;
            version: LavalinkVersion;
            initialized: boolean;
            sessionId?: string | null;
            regions: string[];
            info: LavalinkInfo | null;
            useVersionPath: boolean;
            /** Returns if connected to the Node. */
            get connected(): boolean;
            /** Returns the address for this node. */
            get address(): string;
            /** @hidden */
            static init(manager: Manager): void;
            get poolAddress(): string;
            /**
                * Creates an instance of Node.
                * @param options
                */
            constructor(options: NodeOptions);
            fetchInfo(): Promise<LavalinkInfo | null>;
            fetchVersion(): Promise<string | null>;
            /**
                * Gets all Players of a Node
                */
            getPlayers(): Promise<LavalinkPlayer[]>;
            /**
                * Gets specific Player Information
                */
            getPlayer(guildId: string): Promise<LavalinkPlayer | InvalidLavalinkRestRequest | null>;
            updatePlayer(data: PlayerUpdateInfo): Promise<LavalinkPlayer | Record<string, string>>;
            /**
                * Deletes a Lavalink Player (from Lavalink)
                * @param guildId
                */
            destroyPlayer(guildId: string): Promise<void>;
            /**
                * Updates the session with a resuming key and timeout
                * @param resumingKey
                * @param timeout
                */
            updateSession(resumingKey?: string, timeout?: number): Promise<Session | Record<string, string>>;
            /**
                * Gets the stats of this node
                */
            fetchStats(): Promise<NodeStats | Record<string, string>>;
            /**
                * Get routplanner Info from Lavalink
                */
            getRoutePlannerStatus(): Promise<RoutePlanner>;
            /**
                * Release blacklisted IP address into pool of IPs
                * @param address IP address
                */
            unmarkFailedAddress(address: string): Promise<void>;
            /**
                * Release blacklisted IP address into pool of IPs
                * @param address IP address
                */
            unmarkAllFailedAddresses(): Promise<void>;
            /** Connects to the Node. */
            connect(): void;
            /** Destroys the Node and all players connected with it. */
            destroy(): void;
            /**
                * Makes an API call to the Node
                * @param endpoint The endpoint that we will make the call to
                * @param modify Used to modify the request before being sent
                * @returns The returned data
                */
            makeRequest<T>(endpoint: string, modify?: ModifyRequest): Promise<T>;
            /**
                * Makes an API call to the Node and returns it as TEXT
                * @param endpoint The endpoint that we will make the call to
                * @param modify Used to modify the request before being sent
                * @returns The returned data
                */
            makeTextRequest<T>(endpoint: string, modify?: ModifyRequest): Promise<T>;
            /**
                * Sends data to the Node.
                * @param data
                */
            send(data: unknown): Promise<boolean>;
            protected open(): void;
            protected close(code: number, reason: string): void;
            protected error(error: Error): void;
            protected message(d: Buffer | string): void;
            protected handleEvent(payload: PlayerEvent & PlayerEvents): void;
            protected trackStart(player: Player, track: Track, payload: TrackStartEvent): void;
            protected trackEnd(player: Player, track: Track, payload: TrackEndEvent): void;
            protected queueEnd(player: Player, track: Track, payload: TrackEndEvent): void;
            protected trackStuck(player: Player, track: Track, payload: TrackStuckEvent): void;
            protected trackError(player: Player, track: Track | UnresolvedTrack, payload: TrackExceptionEvent): void;
            protected socketClosed(player: Player, payload: WebSocketClosedEvent): void;
    }
    /** Modifies any outgoing REST requests. */
    export type ModifyRequest = (options: Dispatcher.RequestOptions) => void;
    export interface NodeOptions {
            /** The host for the node. */
            host: string;
            /** The port for the node. */
            port?: number;
            /** The password for the node. */
            password?: string;
            /** Whether the host uses SSL. */
            secure?: boolean;
            /** The identifier for the node. */
            identifier?: string;
            /** The retryAmount for the node. */
            retryAmount?: number;
            /** The retryDelay for the node. */
            retryDelay?: number;
            /** The timeout used for api calls */
            requestTimeout?: number;
            /** Options for the undici http pool used for http requests */
            poolOptions?: Pool.Options;
            /** Regions for region sort */
            regions?: string[];
            /** Lavalink-Version */
            version?: LavalinkVersion;
            /** If it should use the version in the request Path(s) */
            useVersionPath?: boolean;
    }
    export interface LavalinkInfo {
            version: VersionObject;
            buildTime: number;
            git: GitObject;
            jvm: string;
            lavaplayer: string;
            sourceManagers: string[];
            filters: string[];
            plugins: PluginObject[];
    }
    export interface VersionObject {
            semver: string;
            major: number;
            minor: number;
            patch: internal;
            preRelease?: string;
    }
    export interface GitObject {
            branch: string;
            commit: string;
            commitTime: string;
    }
    export interface PluginObject {
            name: string;
            version: string;
    }
    export interface NodeStats {
            /** The amount of players on the node. */
            players: number;
            /** The amount of playing players on the node. */
            playingPlayers: number;
            /** The uptime for the node. */
            uptime: number;
            /** The memory stats for the node. */
            memory: MemoryStats;
            /** The cpu stats for the node. */
            cpu: CPUStats;
            /** The frame stats for the node. */
            frameStats: FrameStats;
    }
    export interface MemoryStats {
            /** The free memory of the allocated amount. */
            free: number;
            /** The used memory of the allocated amount. */
            used: number;
            /** The total allocated memory. */
            allocated: number;
            /** The reservable memory. */
            reservable: number;
    }
    export interface CPUStats {
            /** The core amount the host machine has. */
            cores: number;
            /** The system load. */
            systemLoad: number;
            /** The lavalink load. */
            lavalinkLoad: number;
    }
    export interface FrameStats {
            /** The amount of sent frames. */
            sent?: number;
            /** The amount of nulled frames. */
            nulled?: number;
            /** The amount of deficit frames. */
            deficit?: number;
    }
}

declare module 'erela.js/structures/Player' {
    import { Manager, SearchQuery, SearchResult } from "erela.js/structures/Manager";
    import { Node } from "erela.js/structures/Node";
    import { Queue } from "erela.js/structures/Queue";
    import { LavalinkFilterData, LavalinkPlayerVoice, TimescaleFilter } from "erela.js/structures/Utils";
    import { State, VoiceState } from "erela.js/structures/Utils";
    export type AudioOutputs = "mono" | "stereo" | "left" | "right";
    export const validAudioOutputs: {
            mono: {
                    leftToLeft: number;
                    leftToRight: number;
                    rightToLeft: number;
                    rightToRight: number;
            };
            stereo: {
                    leftToLeft: number;
                    leftToRight: number;
                    rightToLeft: number;
                    rightToRight: number;
            };
            left: {
                    leftToLeft: number;
                    leftToRight: number;
                    rightToLeft: number;
                    rightToRight: number;
            };
            right: {
                    leftToLeft: number;
                    leftToRight: number;
                    rightToLeft: number;
                    rightToRight: number;
            };
    };
    export interface PlayerUpdatePayload {
            state: {
                    connected: boolean;
                    ping: number;
                    position: number;
                    time: number;
            };
            guildId: string;
    }
    export interface PlayerFilters {
            /** Sets nightcore to false, and vaporwave to false */
            custom: boolean;
            /** Sets custom to false, and vaporwave to false */
            nightcore: boolean;
            /** Sets custom to false, and nightcore to false */
            vaporwave: boolean;
            /** only with the custom lavalink filter plugin */
            echo: boolean;
            /** only with the custom lavalink filter plugin */
            reverb: boolean;
            rotation: boolean;
            /** @deprecated */
            rotating: boolean;
            karaoke: boolean;
            tremolo: boolean;
            vibrato: boolean;
            lowPass: boolean;
            /** audio Output (default stereo, mono sounds the fullest and best for not-stereo tracks) */
            audioOutput: AudioOutputs;
            /** Lavalink Volume FILTER (not player Volume, think of it as a gain booster) */
            volume: boolean;
    }
    export class Player {
            options: PlayerOptions;
            /** The Queue for the Player. */
            readonly queue: Queue;
            /** Whether the queue repeats the track. */
            trackRepeat: boolean;
            /** Whether the queue repeats the queue. */
            queueRepeat: boolean;
            /** The time the player is in the track. */
            position: number;
            /** Whether the player is playing. */
            playing: boolean;
            /** Whether the player is paused. */
            paused: boolean;
            /** The volume for the player */
            volume: number;
            /** The real volume for the player (if volumedecrementer is used this will be diffrent to player.volume) */
            lavalinkVolume: number;
            /** The Node for the Player. */
            node: Node;
            /** The guild for the player. */
            guild: string;
            /** The voice channel for the player. */
            voiceChannel: string | null;
            /** The text channel for the player. */
            textChannel: string | null;
            /** The current state of the player. */
            state: State;
            /** The equalizer bands array. */
            bands: number[];
            /** @deprecated The voice state object from Discord. */
            voiceState: VoiceState;
            /** The new VoiceState Data from Lavalink */
            voice: LavalinkPlayerVoice;
            /** The Manager. */
            manager: Manager;
            /** Checker if filters should be updated or not! */
            filterUpdated: number;
            /** When the player was created [Date] (from lavalink) */
            createdAt: Date | null;
            /** When the player was created [Timestamp] (from lavalink) */
            createdTimeStamp: number;
            /** If lavalink says it's connected or not */
            connected: boolean | undefined;
            /** Last sent payload from lavalink */
            payload: Partial<PlayerUpdatePayload>;
            /** A Voice-Region for voice-regioned based - Node identification(s) */
            region: string;
            /** The Ping to the Lavalink Client in ms | < 0 == not connected | undefined == not defined yet. */
            ping: number | undefined;
            /** The Voice Connection Ping from Lavalink in ms | < 0 == not connected | null == lavalinkversion is < 3.5.1 in where there is no ping info. | undefined == not defined yet. */
            wsPing: number | null | undefined;
            /** All States of a Filter, however you can manually overwrite it with a string, if you need so */
            filters: PlayerFilters;
            /** The Current Filter Data(s) */
            filterData: LavalinkFilterData;
            /**
                * Set custom data.
                * @param key
                * @param value
                */
            set(key: string, value: unknown): void;
            /**
                * Get custom data.
                * @param key
                */
            get<T>(key: string): T;
            /** @hidden */
            static init(manager: Manager): void;
            /**
                * Creates a new player, returns one if it already exists.
                * @param options
                */
            constructor(options: PlayerOptions);
            checkFiltersState(oldFilterTimescale?: Partial<TimescaleFilter>): boolean;
            /**
                * Reset all Filters
                */
            resetFilters(): Promise<PlayerFilters>;
            /**
                * Set the AudioOutput Filter
                * @param type
                */
            setAudioOutput(type: AudioOutputs): Promise<AudioOutputs>;
            /**
                * Set custom filter.timescale#speed . This method disabled both: nightcore & vaporwave. use 1 to reset it to normal
                * @param speed
                * @returns
                */
            setSpeed(speed?: number): Promise<boolean>;
            /**
                * Set custom filter.timescale#pitch . This method disabled both: nightcore & vaporwave. use 1 to reset it to normal
                * @param speed
                * @returns
                */
            setPitch(pitch?: number): Promise<boolean>;
            /**
                * Set custom filter.timescale#rate . This method disabled both: nightcore & vaporwave. use 1 to reset it to normal
                * @param speed
                * @returns
                */
            setRate(rate?: number): Promise<boolean>;
            /**
                * Enabels / Disables the rotation effect, (Optional: provide your Own Data)
                * @param rotationHz
                * @returns
                */
            toggleRotation(rotationHz?: number): Promise<boolean>;
            /**
                * @deprected - use #toggleRotation() Enabels / Disables the rotation effect, (Optional: provide your Own Data)
                * @param rotationHz
                * @returns
                */
            toggleRotating(rotationHz?: number): Promise<boolean>;
            /**
                * Enabels / Disables the Vibrato effect, (Optional: provide your Own Data)
                * @param frequency
                * @param depth
                * @returns
                */
            toggleVibrato(frequency?: number, depth?: number): Promise<boolean>;
            /**
                * Enabels / Disables the Tremolo effect, (Optional: provide your Own Data)
                * @param frequency
                * @param depth
                * @returns
                */
            toggleTremolo(frequency?: number, depth?: number): Promise<boolean>;
            /**
                * Enabels / Disables the LowPass effect, (Optional: provide your Own Data)
                * @param smoothing
                * @returns
                */
            toggleLowPass(smoothing?: number): Promise<boolean>;
            /**
                * Enabels / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
                * @param delay
                * @param decay
                * @returns
                */
            toggleEcho(delay?: number, decay?: number): Promise<boolean>;
            /**
                * Enabels / Disables the Echo effect, IMPORTANT! Only works with the correct Lavalink Plugin installed. (Optional: provide your Own Data)
                * @param delay
                * @param decay
                * @returns
                */
            toggleReverb(delay?: number, decay?: number): Promise<boolean>;
            /**
                * Enables / Disabels a Nightcore-like filter Effect. Disables/Overwrides both: custom and Vaporwave Filter
                * @param speed
                * @param pitch
                * @param rate
                * @returns
                */
            toggleNightcore(speed?: number, pitch?: number, rate?: number): Promise<boolean>;
            /**
                * Enables / Disabels a Vaporwave-like filter Effect. Disables/Overwrides both: custom and nightcore Filter
                * @param speed
                * @param pitch
                * @param rate
                * @returns
                */
            toggleVaporwave(speed?: number, pitch?: number, rate?: number): Promise<boolean>;
            /**
                * Enable / Disables a Karaoke like Filter Effect
                * @param level
                * @param monoLevel
                * @param filterBand
                * @param filterWidth
                * @returns
                */
            toggleKaraoke(level?: number, monoLevel?: number, filterBand?: number, filterWidth?: number): Promise<boolean>;
            /** Function to find out if currently there is a custom timescamle etc. filter applied */
            isCustomFilterActive(): boolean;
            updatePlayerFilters(): Promise<Player>;
            /**
                * Same as Manager#search() but a shortcut on the player itself. Custom Node is provided via player.node internally
                * @param query
                * @param requester
                */
            search(query: string | SearchQuery, requester?: unknown): Promise<SearchResult>;
            /**
                * Sets the players equalizer band on-top of the existing ones.
                * @param bands
                */
            setEQ(...bands: EqualizerBand[]): Promise<this>;
            /** Clears the equalizer bands. */
            clearEQ(): Promise<this>;
            /** Connect to the voice channel. */
            connect(): this;
            /** Disconnect from the voice channel. */
            disconnect(): this;
            /** Destroys the player. */
            destroy(disconnect?: boolean): Promise<void>;
            /**
                * Sets the player voice channel.
                * @param channel
                */
            setVoiceChannel(channel: string): this;
            /**
                * Sets the player text channel.
                * @param channel
                */
            setTextChannel(channel: string): this;
            /** Plays the next track. */
            play(): Promise<void>;
            /**
                * Plays the specified track.
                * @param track
                */
            play(track: Track | UnresolvedTrack): Promise<void>;
            /**
                * Plays the next track with some options.
                * @param options
                */
            play(options: PlayOptions): Promise<void>;
            /**
                * Plays the specified track with some options.
                * @param track
                * @param options
                */
            play(track: Track | UnresolvedTrack, options: PlayOptions): Promise<void>;
            /**
                * Sets the player volume.
                * @param volume 0-500
                */
            setVolume(volume: number): Promise<this>;
            /**
                * Applies a Node-Filter for Volume (make it louder/quieter without distortion | only for new REST api).
                * @param volume 0-5
                */
            setVolumeFilter(volume: number): Promise<this>;
            /**
                * Sets the track repeat.
                * @param repeat
                */
            setTrackRepeat(repeat: boolean): this;
            /**
                * Sets the queue repeat.
                * @param repeat
                */
            setQueueRepeat(repeat: boolean): this;
            /** Stops the current track, optionally give an amount to skip to, e.g 5 would play the 5th song. */
            stop(amount?: number): Promise<this>;
            /**
                * Pauses the current track.
                * @param pause
                */
            pause(paused: boolean): Promise<this>;
            /**
                * Seeks to the position in the current track.
                * @param position
                */
            seek(position: number): Promise<this>;
    }
    export interface PlayerOptions {
            /** The guild the Player belongs to. */
            guild: string;
            /** The text channel the Player belongs to. */
            textChannel: string;
            /** The voice channel the Player belongs to. */
            voiceChannel?: string;
            /** The node the Player uses. */
            node?: string;
            /** The initial volume the Player will use. */
            volume?: number;
            /** If the player should mute itself. */
            selfMute?: boolean;
            /** If the player should deaf itself. */
            selfDeafen?: boolean;
            /** Voice-Region */
            region?: string;
            /** If filters should be instantupdated */
            instaUpdateFiltersFix: boolean;
            /** All vars to set on the customDatas */
            customData?: Record<string, string>;
    }
    /** If track partials are set some of these will be `undefined` as they were removed. */
    export interface Track {
            /** @deprecated The base64 encoded track. */
            readonly track: string;
            /** The encoded base64 track. */
            readonly encodedTrack: string;
            /** The title of the track. */
            title: string;
            /** The identifier of the track. */
            identifier: string;
            /** The author of the track. */
            author: string;
            /** The duration of the track. */
            duration: number;
            /** If the track is seekable. */
            isSeekable: boolean;
            /** If the track is a stream.. */
            isStream: boolean;
            /** The uri of the track. */
            uri: string;
            /** The thumbnail of the track or null if it's a unsupported source. */
            thumbnail: string | null;
            /** The user that requested the track. */
            requester: unknown | null;
            /** If the Track is a preview */
            isPreview: boolean;
            /** v4: If the Track has a artworkUrl --> will overwrite thumbnail too! (if not a youtube video) */
            artworkUrl: string | null;
            /** v4: ISRC if available */
            isrc: string | null;
    }
    /** Unresolved tracks can't be played normally, they will resolve before playing into a Track. */
    export interface UnresolvedTrack extends Partial<Track> {
            /** The title to search against. */
            title: string;
            /** The author to search against. */
            author?: string;
            /** The duration to search within 1500 milliseconds of the results from YouTube. */
            duration?: number;
            /** Thumbnail of the track */
            thumbnail?: string;
            /** v4: If the Track has a artworkUrl --> will overwrite thumbnail too! (if not a youtube video) */
            artworkUrl: string | null;
            /** v4: If the Track has a ISRC */
            isrc?: string | null;
            /** Identifier of the track */
            identifier?: string;
            /** If it's a local track */
            local?: boolean;
            /** Resolves into a Track. */
            resolve(): Promise<void>;
    }
    export interface PlayOptions {
            /** The position to start the track. */
            readonly startTime?: number;
            /** The position to end the track. */
            readonly endTime?: number;
            /** Whether to not replace the track if a play payload is sent. */
            readonly noReplace?: boolean;
            /** If to start "paused" */
            readonly pause?: boolean;
            /** The Volume to start with */
            readonly volume?: number;
            /** The Lavalink Filters to use | only with the new REST API */
            readonly filters?: LavalinkFilterData;
    }
    export interface EqualizerBand {
            /** The band number being 0 to 14. */
            band: number;
            /** The gain amount being -0.25 to 1.00, 0.25 being double. */
            gain: number;
    }
}

declare module 'erela.js/structures/Queue' {
    import { Track, UnresolvedTrack } from "erela.js/structures/Player";
    /**
        * The player's queue, the `current` property is the currently playing track, think of the rest as the up-coming tracks.
        * @noInheritDoc
        */
    export class Queue extends Array<Track | UnresolvedTrack> {
            /** The total duration of the queue. */
            get duration(): number;
            /** The total size of tracks in the queue including the current track. */
            get totalSize(): number;
            /** The size of tracks in the queue. */
            get size(): number;
            /** The current track */
            current: Track | UnresolvedTrack | null;
            /** The previous track */
            previous: Track | UnresolvedTrack | null;
            /**
                * Adds a track to the queue.
                * @param track
                * @param [offset=null]
                */
            add(track: (Track | UnresolvedTrack) | (Track | UnresolvedTrack)[], offset?: number): void;
            /**
                * Removes a track from the queue. Defaults to the first track, returning the removed track, EXCLUDING THE `current` TRACK.
                * @param [position=0]
                */
            remove(position?: number): Track[];
            /**
                * Removes an amount of tracks using a exclusive start and end exclusive index, returning the removed tracks, EXCLUDING THE `current` TRACK.
                * @param start
                * @param end
                */
            remove(start: number, end: number): (Track | UnresolvedTrack)[];
            /** Clears the queue. */
            clear(): void;
            /** Shuffles the queue. */
            shuffle(): void;
    }
}

declare module 'erela.js/structures/Utils' {
    import { Manager } from "erela.js/structures/Manager";
    import { Node, NodeStats } from "erela.js/structures/Node";
    import { Player, Track, UnresolvedTrack } from "erela.js/structures/Player";
    import { Queue } from "erela.js/structures/Queue";
    export abstract class TrackUtils {
            static trackPartial: string[] | null;
            /** @hidden */
            static init(manager: Manager): void;
            static setTrackPartial(partial: string[]): void;
            /**
                * Checks if the provided argument is a valid Track or UnresolvedTrack, if provided an array then every element will be checked.
                * @param trackOrTracks
                */
            static validate(trackOrTracks: unknown): boolean;
            /**
                * Checks if the provided argument is a valid UnresolvedTrack.
                * @param track
                */
            static isUnresolvedTrack(track: unknown): boolean;
            /**
                * Checks if the provided argument is a valid Track.
                * @param track
                */
            static isTrack(track: unknown): boolean;
            /**
                * Builds a Track from the raw data from Lavalink and a optional requester.
                * @param data
                * @param requester
                */
            static build(data: Partial<TrackData>, requester?: unknown): Track;
            /**
                * Builds a UnresolvedTrack to be resolved before being played  .
                * @param query
                * @param requester
                */
            static buildUnresolved(query: string | UnresolvedQuery, requester?: unknown): UnresolvedTrack;
            static getClosestTrack(unresolvedTrack: UnresolvedTrack, customNode?: Node): Promise<Track>;
    }
    /** Gets or extends structures to extend the built in, or already extended, classes to add more functionality. */
    export abstract class Structure {
            /**
                * Extends a class.
                * @param name
                * @param extender
                */
            static extend<K extends keyof Extendable, T extends Extendable[K]>(name: K, extender: (target: Extendable[K]) => T): T;
            /**
                * Get a structure from available structures by name.
                * @param name
                */
            static get<K extends keyof Extendable>(name: K): Extendable[K];
    }
    export class Plugin {
            load(manager: Manager): void;
            unload(manager: Manager): void;
    }
    export interface UnresolvedQuery {
            /** The title to search against. */
            title: string;
            /** The author to search against. */
            author?: string;
            /** The duration to search within 1500 milliseconds of the results from YouTube. */
            duration?: number;
            /** Thumbnail of the track */
            thumbnail?: string;
            /** If the Track has a artworkUrl --> will overwrite thumbnail too! (if not a youtube video) */
            artworkUrl: string | null;
            /** Identifier of the track */
            identifier?: string;
            /** If it's a local track */
            local?: boolean;
    }
    export type Sizes = "0" | "1" | "2" | "3" | "default" | "mqdefault" | "hqdefault" | "maxresdefault";
    export type LoadType = "TRACK_LOADED" | "PLAYLIST_LOADED" | "SEARCH_RESULT" | "LOAD_FAILED" | "NO_MATCHES";
    export type v4LoadType = "track" | "playlist" | "search" | "error" | "empty";
    export type State = "CONNECTED" | "CONNECTING" | "DISCONNECTED" | "DISCONNECTING" | "DESTROYING";
    export type PlayerEvents = TrackStartEvent | TrackEndEvent | TrackStuckEvent | TrackExceptionEvent | WebSocketClosedEvent;
    export type PlayerEventType = "TrackStartEvent" | "TrackEndEvent" | "TrackExceptionEvent" | "TrackStuckEvent" | "WebSocketClosedEvent";
    export type TrackEndReason = "FINISHED" | "LOAD_FAILED" | "STOPPED" | "REPLACED" | "CLEANUP";
    export type Severity = "COMMON" | "SUSPICIOUS" | "FAULT";
    export interface InvalidLavalinkRestRequest {
            timestamp: number;
            status: number;
            error: string;
            message?: string;
            path: string;
    }
    export interface LavalinkPlayerVoice {
            token: string;
            endpoint: string;
            sessionId: string;
            connected?: boolean;
            ping?: number;
    }
    export interface LavalinkPlayerVoiceOptions extends Omit<LavalinkPlayerVoice, 'connected' | 'ping'> {
    }
    export interface PlayerUpdateOptions {
            encodedTrack?: string | null;
            identifier?: string;
            position?: number;
            endTime?: number;
            volume?: number;
            paused?: boolean;
            filters?: Partial<LavalinkFilterData>;
            voice?: LavalinkPlayerVoiceOptions;
    }
    export interface PlayerUpdateInfo {
            guildId: string;
            playerOptions: PlayerUpdateOptions;
            noReplace?: boolean;
    }
    export interface LavalinkPlayerUpdateTrack {
            encoded?: string;
            info: TrackDataInfo;
    }
    export interface LavalinkPlayer {
            guildId: string;
            track?: LavalinkPlayerUpdateTrack;
            volume: number;
            paused: boolean;
            voice: LavalinkPlayerVoice;
            filters: Partial<LavalinkFilterData>;
    }
    export interface FetchOptions {
            endpoint: string;
            options: {
                    headers?: Record<string, string>;
                    params?: Record<string, string>;
                    method?: string;
                    body?: Record<string, unknown>;
                    [key: string]: unknown;
            };
    }
    export interface UsedFetchOptions {
            method: string;
            headers: Record<string, string>;
            signal: AbortSignal;
            body?: string;
    }
    export interface Address {
            address: string;
            failingTimestamp: number;
            failingTime: string;
    }
    export interface RoutePlanner {
            class?: string;
            details?: {
                    ipBlock: {
                            type: string;
                            size: string;
                    };
                    failingAddresses: Address[];
            };
            rotateIndex?: string;
            ipIndex?: string;
            currentAddress?: string;
            blockIndex?: string;
            currentAddressIndex?: string;
    }
    export interface Session {
            resumingKey?: string;
            timeout: number;
    }
    export interface LavalinkPlayerVoice {
            token: string;
            endpoint: string;
            sessionId: string;
            connected?: boolean;
            ping?: number;
    }
    export interface TrackData {
            /** @deprecated */
            track?: string;
            encoded?: string;
            encodedTrack?: string;
            info: Partial<TrackDataInfoExtended>;
            pluginInfo: Partial<PluginDataInfo> | Record<string, string | number>;
    }
    /** Data from Lavalink */
    export interface TrackDataInfo {
            title: string;
            identifier: string;
            author: string;
            length: number;
            isSeekable: boolean;
            position?: number;
            isStream: boolean;
            uri: string;
            sourceName: string;
            artworkUrl: string | null;
            isrc: string | null;
    }
    export interface TrackDataInfoExtended extends TrackDataInfo {
            /** Things provided by an library */
            thumbnail?: string;
            /** Things provided by a library */
            md5_image?: string;
            /** Things provided by a library */
            image?: string;
    }
    export interface PluginDataInfo {
            type?: string;
            identifier?: string;
            artworkUrl?: string;
            author?: string;
            url?: string;
    }
    export interface Extendable {
            Player: typeof Player;
            Queue: typeof Queue;
            Node: typeof Node;
    }
    export interface VoiceState {
            op: "voiceUpdate";
            guildId: string;
            event: VoiceServer;
            sessionId?: string;
            guild_id: string;
            user_id: string;
            session_id: string;
            channel_id: string;
    }
    export interface VoiceServer {
            token: string;
            guild_id: string;
            endpoint: string;
    }
    export interface VoicePacket {
            t?: "VOICE_SERVER_UPDATE" | "VOICE_STATE_UPDATE";
            d: VoiceState | VoiceServer;
    }
    export interface NodeMessage extends NodeStats {
            type: PlayerEventType;
            op: "stats" | "playerUpdate" | "event";
            guildId: string;
    }
    export interface PlayerEvent {
            op: "event";
            type: PlayerEventType;
            guildId: string;
    }
    export interface Exception {
            severity: Severity;
            message: string;
            cause: string;
    }
    export interface TrackStartEvent extends PlayerEvent {
            type: "TrackStartEvent";
            track: string;
    }
    export interface TrackEndEvent extends PlayerEvent {
            type: "TrackEndEvent";
            track: string;
            reason: TrackEndReason;
    }
    export interface TrackExceptionEvent extends PlayerEvent {
            type: "TrackExceptionEvent";
            exception?: Exception;
            error: string;
    }
    export interface TrackStuckEvent extends PlayerEvent {
            type: "TrackStuckEvent";
            thresholdMs: number;
    }
    export interface WebSocketClosedEvent extends PlayerEvent {
            type: "WebSocketClosedEvent";
            code: number;
            byRemote: boolean;
            reason: string;
    }
    export interface PlayerUpdate {
            op: "playerUpdate";
            state: {
                    position: number;
                    time: number;
            };
            guildId: string;
    }
    export interface EQBand {
            band: number;
            gain: number;
    }
    export interface KaraokeFilter {
            level?: number;
            monoLevel?: number;
            filterBand?: number;
            filterWidth?: number;
    }
    export interface TimescaleFilter {
            speed?: number;
            pitch?: number;
            rate?: number;
    }
    export interface FreqFilter {
            frequency?: number;
            depth?: number;
    }
    export interface RotationFilter {
            rotationHz?: number;
    }
    export interface DistortionFilter {
            sinOffset?: number;
            sinScale?: number;
            cosOffset?: number;
            cosScale?: number;
            tanOffset?: number;
            tanScale?: number;
            offset?: number;
            scale?: number;
    }
    export interface ChannelMixFilter {
            leftToLeft?: number;
            leftToRight?: number;
            rightToLeft?: number;
            rightToRight?: number;
    }
    export interface LowPassFilter {
            smoothing?: number;
    }
    export interface EchoFilter {
            delay: number;
            decay: number;
    }
    export interface ReverbFilter {
            delay: number;
            decay: number;
    }
    export interface LavalinkFilterData {
            volume?: number;
            equalizer?: EQBand[];
            karaoke?: KaraokeFilter;
            timescale?: TimescaleFilter;
            tremolo?: FreqFilter;
            vibrato?: FreqFilter;
            rotation?: RotationFilter;
            distortion?: DistortionFilter;
            channelMix?: ChannelMixFilter;
            lowPass?: LowPassFilter;
            echo: EchoFilter;
            reverb: ReverbFilter;
    }
}

